///*
//	在二叉树中查找值为x的节点，试编写算法打印值为x的节点的所有祖先，假设x的值不多于一个。
//	分析：
//		这里我们采用后序遍历（非递归），因为在我们遇到x之前我们会把它的祖先节点全部入栈，当我们找到x时，再依次取出栈中元素
//*/
//
//#include <stdio.h>
//#include <stdlib.h>
//#include "biTreeStruct.h"//通过头文件加载二叉树结构体
//#include "stackStruct.h"//通过头文件加载栈结构体
//
//void findAllAncestor(biTree *T, Stack *s, char x) {
//	biTree *p = T;
//	biTree *r = (biTree *)malloc(sizeof(biTree));
//	biTree *tp = (biTree *)malloc(sizeof(biTree));
//
//	bool push(Stack *, biTree*);
//	bool pop(Stack *);
//	biTree *top(Stack *);//返回得是一个指针
//	bool empty(Stack *);
//	while (p || !empty(s)) {
//		if (p) {//一路将所有左孩子入栈
//			push(s, p);
//			p = p->lchild;
//		}
//		else {//没有左孩子，
//			p = top(s);
//			if (p->rchild && p->rchild != r) {//若存在右子树且未被访问，将右子树的左子树依次入栈
//				p = p->rchild;
//			}
//			else {//当既没有左孩子也没有右孩子时，该出栈了
//				pop(s);//被查找元素先出栈
//				if (p->data == x) {//找到了，那么如果栈中有元素，那全都是它的祖先
//					printf("祖先元素有:");
//					while (!empty(s)) {
//						tp = top(s);
//						printf("%c ", tp->data);
//						pop(s);
//					}
//
//				}
//				r = p;
//				p = NULL;//一定要将p置空，不然又会把p的左孩子入栈
//			}
//		}
//
//
//	}
//}
//int main() {
//	int count = 0, x;
//	biTree *T = (biTree *)malloc(sizeof(struct biTree));
//	struct Stack *s;
//
//	biTree *create(biTree *,int);
//	void nodeNum(biTree *, int *);
//
//	Stack *createStack(int);
//
//	T = create(T,1);
//	nodeNum(T, &count);
//	s = createStack(count);
//	printf("请输入要查找的元素：x=");
//	x = getchar();
//	findAllAncestor(T, s, x);
//	return 0;
//}
/*

B站：北街lhy
配套视频链接：
https://www.bilibili.com/video/BV1mh411Y75c?spm_id_from=333.999.0.0
*/